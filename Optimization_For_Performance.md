# 调优介绍 #

先大刀阔斧完完成从无到有的功能，初步跑通，增强自信。那下一步就该是抽丝剥茧搬的调优过程了。

关于调优的几个断言——
  * 调优过程将是无止尽的.
  * 任何优化都是有代价的.

HLFS项目存在大量可调整的理由和办法，可谓仁者见仁智者见智。我们将从从收益角度和实现代价考虑，逐步开展。
因为很多优化办法具备普遍意义，所以我们费一些笔墨描述之。


# 调优点 #

## indirect block read cache ##
我们知道，每次访问data block，只要需要从磁盘中载入或者写入，就必须首先访问indirect block（如果db在cache则不需要再从磁盘载入），显然这些indirect block访问相当频繁，如果访问ib时，每每都操作磁盘，那对性能无疑是个重大损失。所以我们尽可能希望最近访问的ib能被缓存起来，从而避免磁盘访问。
所以，我们实现ICACHE缓存（indirect block cache），和DCATCH(data block cache)写缓存相比，ICACHE最大特点是它属于读缓存，并不需要向DCACHE那样WRITEBACK ——　因为ib会随db一起在dump\_log时被写到后台。 ICACHE实现和DACHE有所相似，不过没有后台刷新线程。
另外值得一提的是，iblock当前编号规则按照简单的遍历顺序而给定，且和dblock相互独立。这是当前简单实现，后期可以采用基树替代简单hash；采用iblock dblock统一编号带台当前独立编号。

## segment file handler reuse ##
我们知道，每次读写一个段文件都要经历打开文件-访问文件-关闭文件几个过程，这种频繁的打开和关闭无疑是性能提升的重要障碍，所以我们要想方设法降低打开文件和关闭文件操作。
比较理想办法应该是：
  * 预先打开段文件（比如每次需要打开或创建段文件时，一次行打开或创建后续n个),从而避免频繁打开段文件；
  * 延迟关闭段文件，或者惰性关闭其（比如，每次访问段内容后并非立刻关闭段文件句柄，而是延后关闭）

我们本次优化，先简单处理——实施延迟关闭方式减少每次block访问都打开关闭文件。

## 锁优化 ##
目前系统最大锁争用在于：read\_block 和 append\_log之间的锁竞争。可能引起并发的几个线是：
  1. cache 回写动作
  1. seg clean 读写动作
  1. 读写操作引起的read block读动作

我们要争取所有的IO动作不再锁内，也就是竞争区中不包含耗时的IO动作。
所以制定以下几个策略：
  1. 修改内存索引iblock和磁盘数据的次序调整为——先修改磁盘数据再修改内存索引，而上锁区间从原来的整个append\_log，降低到只包含内存索引修改，甚至可以不加锁（这里不必担心读到老数据，因为我们的cache会确保读到最新）。这种方法确保了读写之间少竞争或者无竞争。
  1. seg clean task 中的搬迁动作采用乐观锁方式—— 因为seg clean操作其实是“check and modify"动作，该动作序列要求原子完成（否则就有可能造成数据错乱，原因如果在check和modify之间隙，有正常写入动作，且正好是待搬迁的数据，则有会出现搬迁旧数据覆盖新数据），所以上锁在所难免，但这个锁区域显然不小。不过我们seg clean任务执行特征是延后且不紧急动作，只有当没有真实写入动作时才会抽空执行，因此我们不妨简化锁设计，采用乐观锁方式（这种方法确保了锁过程变短），即：
    1. seg clean task 在 check 动作前纪录inode修改时间戳
    1. seg clean task 在 modify 内存inode结构前发现inode时间戳已被修改则放弃本次modify动作，如果时间戳没有被修改才执行modify动作。—— 不过这里要注意，两个写者本身要互斥。

## 优化内存使用 ##
  1. 对于频繁调用路径上内存使用应尽量避免动态堆上分配，能在栈上分配则不在堆上进行，甚至有写地方我们使用callca在栈上分配（虽然该函数的可移植性一直被诟病）
  1. 可以预先分配的则预先分配，避免动态分配。
  1. 函数定义趋向于由调用者给定缓存区，而尽量不又被调用方分配。以便将内存优化权交给调用者。



--待续