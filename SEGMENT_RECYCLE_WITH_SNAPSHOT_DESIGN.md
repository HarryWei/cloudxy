# 快照区间下段回收设计 #

Log Structure的存储系统都跑不了旧数据回收这个环节。回收数据的算法好坏不但影响到磁盘占用率，更会影响到和读写访问性能。根据个人经验来看，
旧数据回收也是容易出bug的地方（而且这里的bug很可能破坏数据），因此我们特别强调段回收算法和策略，单独作为一个子模块加以设计和实施。

# 算法概述 #
我们知道，HLFS的inode结构会记录（通过各级索引）逻辑块和其物理存储地址的映射关系，也就是通过逻辑块号能找到其存储块位置。在这个前提下，我们要判断一个log中的存储块(data block)是否是旧数据，其实只需要根据该存储块是否能被给定inode索引到来判断——能索引到说明是活跃块（alive block),不能被索引到则是旧数据块（old block)。如果一个段中的所有数据块都是旧数据块，那么这个段文件则可被直接回收（直接删除段文件即可——我们称为简单回收）。

# 强制回收段文件 #
简单回收要求一个段被回收要求绝对不存在活跃块。但是很有可能一个段中只有少量活跃块，这种情况下不回收其实在是种浪费，所以我们想办法搬迁这写少量的活跃块——将其以新数据块形式写入新log,从而“帮助”该段达到无活跃块状态，进而能被回收。 我们称其为 move & remove 策略。

# 快照条件下段回收 #
在快照情况下回收段文件：快照可以说是段回收的拦路虎，因为其将需要固化历史版本，使得段回收的范围不再是全局性，而是只能按照快照区间进行——和无快照环境相比，参照的inode结构不再是次新inode，而是上游快照(up snapshot）所在的inode。<br>
另外，强制回收段的方式在快照条件下很难适用，因为一旦搬迁某个快照区间的某个block，则意味着破坏了后续inode的寻址（无法再找到搬迁后的块）。到目前为止我们还没找到一个高效解决该问题的方法，所以快照间的段回收目前不进行强制回收动作。<br>
<br>
<h1>段回收相关策略</h1>
<ol><li>.分步执行策略—— 我们将整个段回收分为两个主要阶段：“段统计”，“段搬迁” 和一个辅助阶段“段删除”。对于“非快照区间内”的段回收过程分为“段统计”和“段搬迁”两个阶段——“段统计”和“段搬迁”分别对应“简单回收”和“强制回收”。<br>
<ul><li>"段统计”阶段计算段中块的活跃率等统计信息，如果无活跃块的段文件可以直接删除。对于不能直接删除的段，则生成一个"段统计文件"，每个段的统计信息记录为一项(称为"段统计记录")。在统计过程对于非快照区间使用的参照inode用次新inode。<br>
</li><li>"段搬迁" 阶段执行强制搬迁过程，根据段统计结果中那些活跃块较少的段（低于给定水位线），进行move & remove 操作 —— 注意这是个模糊判断，因为段统计时刻和段搬迁时刻之间可能已经有很多改变，统计时alive block可能已经是非old block了（但old block不会变为alive block)，所以段统计是各非精确的参考值。段搬迁需要修改该段的段统计记录（追加写入新的段统计记录，alive block此刻已经为0）。对于“快照区间"段回收过程只包括“段统计阶段"。<br>
</li><li>"段删除" 阶段其实段删除就意味着数据销毁（从hdfs中删除，回收存储空间），所以我们采取谨慎策略，删除动作都不和段统计和搬迁过程混合，而是后期单独执行。这个过程主要检查段统计记录，发现alive block为0的段，进行删除）。<br>
</li></ul></li><li>推拉执行策略—— 对于段统计阶段的操作，可采用本地客户端“拉模式”进行——也就是说将段数据读到本地，在本地执行统计，然后更新段统计文件；也可采用map/reduce“推模式“进行——也就是说到段所在机器就近计算段信息统计。<br>
</li><li>带外执行和带内执行策略 —— "段统计"过程采用带外执行策略，也就是说由独立的standalone程序（拉模式）或者M/R任务执行（推模式）执行，其运行和hlfs在线系统无关；而“段搬迁”过程要带内执行，需要在hlfs写入流程中加入搬迁任务，原因和具体做法见下文。<br>
</li><li>HDFS使用中的文件操作已经采用强制锁保护，不允许同时两个写者操作文件，如果有读者也不允许删除文件。所以上述过程中更新或者删除文件时如报错—JAVA 是IOEXCEPTION,C接口就是open 反错",说明文件此刻被占用，retry即可；我们读取访问文件时要注意，不能长期持有文件句柄，将文件数据读取后或者数据写入后，即要关闭文件句柄。对于local mode下文件访问不是强制锁而是非强制锁，所以理论上有可能出现写乱情况，但实际中我们追加写操作数据小于4096(linux保证4096内追加的原子性）,所以不大会些乱。</li></ol>

<h1>名词解释</h1>
<ul><li>快照区间： 两个快照之间的连续段。按照时间序左区间快照叫下游快照down snapshot，右区间快照叫up snapshot。<br>
</li><li>非快照区间：最后一个快照之后的所有连续段。如果没有任何一个快照，全部段都属于非快照区间，如果有快照，则最后一个快照到当前操作段都叫非快照区间。<br>
</li><li>活跃块：<br>
</li><li>旧块：<br>
</li><li>次新inode: 我们定义为当前段的prev段的最后一个inode为次新inode。使用次新inode而非最新inode纯粹是为了简单，找一个不变量。</li></ul>

<h1>基本数据结构</h1>
<pre><code>快照结构<br>
struct snapshot_t {<br>
     uint64_t timestamp;<br>
     uint64_t inode_addr;<br>
     char sname[HLFS_FILE_NAME_MAX];<br>
     char up_sname[HLFS_FILE_NAME_MAX]; /* for tree style snapshot */<br>
};<br>
段统计结构<br>
struct seg_usage_t{<br>
         uint64_t seg_no；<br>
         char up_snapshot[128]；up快照，对于非快照区间的段而言，这个值可以是空。<br>
         uint64_t inode_saddr ；快照间的段该值为up快照地址值，非快照区间则是次新inode地址。<br>
         uint64_t timestamp   ；统计时刻时间戳<br>
         uint32_t log_num     ；段中总共的log数据<br>
         uint32_t block_num   ；段中总共的date block数<br>
         uint32_t alive_block_num ；段中活跃块data block数<br>
         uint32_t bitmap_size;位图长度，字节长度。<br>
         char     *alive_log_bitmap；存在有alive block的log位图，暂时粒度到log。每一位对应段中一个log，如果该log中有脏页则标记为1. <br>
}<br>
这个结构需要能持久化和反持久化——写入磁盘和从磁盘中读取<br>
</code></pre>

<h1>算法要点</h1>

<b>段统计</b>

<ol><li>.先查找段统计文件和段删除标记文件，查看该段是否存在。如果段存在，且在段统计文件中，且又在段删除标志中存在则说明没执行离线段删除，跳过其。如果段已经不存在，也跳过其。<br>
</li><li>.根据段号找到回收过程要使用的参考inode —— 先确定是否该段处于快照区间内，如果在快照区间内，则找到up snapshot对应的inode_addr做参考（注意已有的段统计中记录的inode_addr和当前找到的up snapshot的inode_addr不符合，则说明原有快照被删除，<br>
则需要重新做段统计，否则不需要做）；如果在非快照区间内，则找次新inode（注意已有的段统计中记录的inode_addr和当前找到的次新inode_addr不符，且当前此新inode和记录中的inode跨越的段数超过给定水位，则也要重新计算段统计）。<br>
</li><li>.对于一个段上存在多个快照的情况，目前先不做处理（复杂度较高），该段不做统计，忽略它。<br>
</li><li>.如果统计出某个段的live block为0,不直接删除。而是记录到段删除标记文件中。待后期删除。<br>
</li><li>.我们会跳过段统计文件中存在一些过期项（段统计项中alive block为0，且段文件已经被删除），这些过期项在一定时刻通过rewrite消除。<br>
</li><li>.段统计过程为了调试等目的，我们希望按照段好大小依次进行（也就是按照段生成顺序）。<br>
</li><li>.快照区间段统计时，对于up snapshot所在的段不做处理。<br>
<b>段搬迁</li></ol></b>

<ol><li>如果段统计文件中某段为的alive block为0，则忽略跳过。<br>
</li><li>段搬迁操作对于当前inode而言是个类似于“check and modify”的原子操作（check-查询inode是否仍然索引到给定存储块;modify-作为新log追加写要修改inode的索引）。这里关键是要保证对inode查询和修改的原子性（不能让正常写入打断，那样就有可能旧数据块覆盖新数据块了）；而且同时我们希望搬迁动作优先级低于正常写入动作——只有在系统无写压力时才进行搬迁，确定几秒内没有写动作后，才会执行搬迁动作。为此目的我们采用单线程模式实现写入优先级和搬迁的原子性操作。<br>
</li><li>另外要注意，为了确保写请求能抢占执行，所以搬迁动作粒度不呢太大，每次处理完一个段的搬迁后，就需要检查是否有请求，如果有则要打断搬迁工作，抢占式执行写操作；当再次进入无写状态时，搬迁过程又继续进行。<br>
</li><li>搬迁完成后修改段统计文件——追加式更新该段的段统计记录。<br>
</li><li>每轮扫描结束后（扫描了初始时读入的所有段统计文件），下一轮执行前都需要重新加载段统计文件（因为有可能期间统计文件有变）<br>
</li><li>段搬迁过程为了调试等目的，我们希望按照段好大小依次进行（也就是按照段生成顺序）</li></ol>

<img src='http://cloudxy.googlecode.com/svn/wiki/images/seg-clean.png' />
<h1>涉及的几个带外工具</h1>
<ul><li>段统计（拉模式）工具—— 支持段粒度、区间力度、和全范围统计，即可只扫描给定段，给定区间内的段（给定开始和结束的连续段区），和全部范围段。<br>
</li><li>段统计（推模式）工具—— 支持区间力度、和全范围统计。<br>
</li><li>段搬迁离线工具：（确保当前hlfs未挂载情况下使用）。指定水位阀值、支持按照段力度。<br>
</li><li>段删除工具：扫描段统计文件，发现alive block为0的段文件，进行删除<br>
段统计文件Merge工具：将段统计文件中alive block的段统计记录去除（只有当对应的段不存在时）。</li></ul>

wroten by kanghua<br>
