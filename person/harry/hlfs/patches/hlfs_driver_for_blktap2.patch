diff -Naur new-prj/blktap2/control/Makefile old-prj/blktap2/control/Makefile
--- new-prj/blktap2/control/Makefile	2011-11-26 13:32:06.000000000 +0800
+++ old-prj/blktap2/control/Makefile	2011-11-26 13:34:39.000000000 +0800
@@ -5,6 +5,10 @@
 MINOR              = 0
 LIBNAME            = libblktapctl
 LIBSONAME          = $(LIBNAME).so.$(MAJOR)
+HLFS_DIR		   = /hlfs
+HLFS_LOG 		   = $(HLFS_DIR)/3part/log
+GLIB_DIR1 		   = /usr/lib/glib-2.0/include
+GLIB_DIR2 		   = /usr/include/glib-2.0
 
 IBIN               = tap-ctl
 
@@ -12,8 +16,13 @@
 CFLAGS            += -Wno-unused
 CFLAGS            += -I../include -I../drivers
 CFLAGS            += -I$(XEN_INCLUDE) -I$(XEN_LIBXC)
+CFLAGS            += -I $(HLOG)/include
 CFLAGS            += -D_GNU_SOURCE
 CFLAGS            += -DTAPCTL
+CFLAGS    		  += -I $(HLFS_DIR)/src/include
+CFLAGS    		  += -I $(GLIB_DIR1)
+CFLAGS    		  += -I $(GLIB_DIR2)
+CFLAGS    		  += -I $(HLFS_LOG)/include
 
 # Get gcc to generate the dependencies for us.
 CFLAGS            += -Wp,-MD,.$(@F).d
@@ -44,6 +53,9 @@
 LIB_SHARED = $(LIBSONAME).$(MINOR)
 IBIN = tap-ctl
 
+LIBS += -L$(HLFS_DIR)/output/lib64/ -lhlfs
+LIBS += -L$(HLFS_LOG)/lib64 -llog4c
+
 all: build
 
 build: $(IBIN) $(LIB_STATIC) $(LIB_SHARED)
@@ -54,8 +66,8 @@
 $(LIBSONAME): $(LIB_SHARED)
 	ln -sf $< $@
 
-tap-ctl: tap-ctl.o $(LIBNAME).so
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^
+tap-ctl: tap-ctl.o $(LIBNAME).so 
+	$(CC) $(CFLAGS) $(LIBS) $(LDFLAGS) -o $@ $^
 
 $(LIB_STATIC): $(CTL_OBJS)
 	$(AR) r $@ $^
diff -Naur new-prj/blktap2/drivers/block-hlfs.c old-prj/blktap2/drivers/block-hlfs.c
--- new-prj/blktap2/drivers/block-hlfs.c	1970-01-01 08:00:00.000000000 +0800
+++ old-prj/blktap2/drivers/block-hlfs.c	2011-11-26 14:06:44.000000000 +0800
@@ -0,0 +1,275 @@
+/* 
+ * Copyright (c) 2007, XenSource Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of XenSource Inc. nor the names of its contributors
+ *       may be used to endorse or promote products derived from this software
+ *       without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+
+#include "blk.h"
+#include "tapdisk.h"
+#include "tapdisk-driver.h"
+#include "tapdisk-interface.h"
+#include "api/hlfs.h"
+#include <glib.h>
+#include <glib/gstdio.h>
+
+#define MAX_HLFSDISK_SIZE 10240000000 /*500G*/
+#include "hlfs_log.h"
+
+char *img;
+long int   disksector_size;
+long int   disksize;
+long int   diskinfo;
+static int connections = 0;
+
+struct tdhlfs_state {
+       HLFS_CTRL *hlfs_ctrl;
+};
+
+
+static int get_hlfs_disk_info(const char *name,char **uri){
+    int ret = 0;
+    *uri = g_strdup(name);
+	DPRINTF("uri is %s\n", *uri);
+out:
+    return ret;
+}
+
+/*Get Image size, secsize*/
+static int set_image_info(long int size,td_disk_info_t *info)
+{
+	int ret;
+    info->size =(uint64_t) ((size * 1024 * 1024) >> SECTOR_SHIFT);
+    info->sector_size = DEFAULT_SECTOR_SIZE;
+
+	DPRINTF("enter func %s", __func__);
+	info->info = 0;
+    /*Store variables locally*/
+	disksector_size = info->sector_size;
+	disksize        = info->size;
+	diskinfo        = info->info;
+	DPRINTF("Image sector_size: \n\t[%"PRIu64"]\n",
+		info->sector_size);
+	DPRINTF("leave func %s", __func__);
+	return 0;
+}
+
+static char *build_ctrl_region(const char *testfs)
+{
+	int fd, offset;
+	CTRL_REGION_T ctrl_region;
+	char ctrl_region_file[128];
+	char *addr = NULL;
+
+	sprintf(ctrl_region_file, "%s%s%s", "/tmp/", testfs, "-ctrl");
+	g_remove(ctrl_region_file);
+	fd = open(ctrl_region_file, O_RDWR | O_CREAT, 0666);
+	if (fd == -1) {
+		DPRINTF("%s -- open failed\n", __func__);
+		return NULL;
+	}
+	offset = sysconf(_SC_PAGE_SIZE);
+	if (-1 == write(fd, &ctrl_region, sizeof(CTRL_REGION_T))) {
+		DPRINTF("%s -- write error!\n", __func__);
+		return NULL;
+	}
+	addr = mmap(NULL, sizeof(CTRL_REGION_T), PROT_WRITE, MAP_SHARED, fd, 0);
+	if (addr == NULL) {
+		DPRINTF("%s -- mmap failed!\n", __func__);
+		return NULL;
+	}
+	return addr;
+}
+
+/*  name format:
+ *  uri/fsname:size(m)
+ *  eg: local:///tmp/testenv/testfs:1024
+ */
+
+/* Open the disk file and initialize ram state. */
+int tdhlfs_open (td_driver_t *driver, const char *name, td_flag_t flags)
+{
+	char *p;
+	uint64_t size;
+    int hlfs_disk_size; /*M*/
+	int i, ret = 0, count = 0;
+	struct tdhlfs_state *prv = (struct tdhlfs_state *)driver->data;
+    char *uri = NULL;
+	char *ctrl_region = NULL;
+    HLFS_CTRL *ctrl = NULL;
+	HLFS_STAT_T stat;
+
+	connections++;
+	if (connections > 1) {
+		driver->info.sector_size = disksector_size;
+		driver->info.size        = disksize;
+		driver->info.info        = diskinfo; 
+		DPRINTF("Image already open, returning parameters:\n");
+		DPRINTF("Image size: \n\tpre sector_shift  [%llu]\n\tpost "
+			"sector_shift [%llu]\n",
+			(long long unsigned)(driver->info.size << SECTOR_SHIFT),
+			(long long unsigned)driver->info.size);
+		DPRINTF("Image sector_size: \n\t[%"PRIu64"]\n",
+			driver->info.sector_size);
+		printf("Image size: \n\tpre sector_shift  [%llu]\n\tpost "
+			"sector_shift [%llu]\n",
+			(long long unsigned)(driver->info.size << SECTOR_SHIFT),
+			(long long unsigned)driver->info.size);
+		printf("Image sector_size: \n\t[%"PRIu64"]\n",
+			driver->info.sector_size);
+		prv->hlfs_ctrl = NULL;
+		goto done;
+	}
+    if(0!=get_hlfs_disk_info(name,&uri)){
+       DPRINTF("failed to parse hlfs disk parameter:%s \n",name);
+       ret = -1;
+       goto done;
+    }
+	DPRINTF("info.size is %llu", (long long unsigned)driver->info.size);
+    DPRINTF("name:%s,uri:%s\n",name,uri);
+	HLOG_DEBUG("%s -- uri is %s, name is %s", __func__, uri, name);
+    ctrl = init_hlfs(uri);
+	DPRINTF("%s -- over init hlfs", __func__);
+    if(ctrl == NULL){
+		DPRINTF("Unable to open [%s]!\n",uri);
+        	ret = -1;
+        	goto done;
+    }
+    prv->hlfs_ctrl = ctrl;
+	if (0 != hlfs_stat(ctrl, &stat)) {
+		DPRINTF("Failed to get hlfs's stat");
+		ret = -1;
+		goto done;
+	}
+	ctrl_region = build_ctrl_region(stat.fsname);
+	DPRINTF("mmap's addr is %p\n", ctrl_region);
+	if (ctrl_region != NULL) {
+		DPRINTF("%s -- enter hlfs_set_user_ctrl_region", __func__);
+		hlfs_set_user_ctrl_region(ctrl, (CTRL_REGION_T *) ctrl_region);
+		DPRINTF("%s -- is_start_clean is %d, copy_waterlevel is %d\n", __func__, 
+				g_atomic_int_get(&ctrl->ctrl_region->is_start_clean), 
+					g_atomic_int_get(&ctrl->ctrl_region->copy_waterlevel));
+	}
+	DPRINTF("%s -- ctrl_region's addr is %p\n", __func__, ctrl_region);
+	DPRINTF("%s -- ctrl->ctrl_region's addr is %p\n", __func__, ctrl->ctrl_region);
+	if (0 != hlfs_open(ctrl, 1)) {
+		DPRINTF("Unable to connect storage!\n");
+		ret = -1;
+		goto done;
+	}
+	hlfs_disk_size = stat.max_fs_size;
+    ret = set_image_info(hlfs_disk_size,&driver->info);
+	if (driver->info.size > MAX_HLFSDISK_SIZE) {
+		DPRINTF("Disk exceeds limit, must be less than [%ld]MB",
+			(MAX_HLFSDISK_SIZE<<SECTOR_SHIFT)>>20);
+		return -ENOMEM;
+	}
+done:
+	return ret;
+}
+
+void tdhlfs_queue_read(td_driver_t *driver, td_request_t treq)
+{
+    int ret = 0;
+	struct tdhlfs_state *prv = (struct tdhlfs_state *)driver->data;
+	int      size    = treq.secs * driver->info.sector_size;
+	uint64_t offset  = treq.sec * (uint64_t)driver->info.sector_size;
+    HLFS_CTRL *ctrl = prv->hlfs_ctrl;
+    ret = hlfs_read(ctrl,treq.buf,size,offset);
+    if(ret == size){
+		DPRINTF("%s -- enter td_complete_request second parameter is 0", __func__);
+	   td_complete_request(treq, 0);
+    }else{
+		DPRINTF("%s -- enter td_complete_request second parameter is -1", __func__);
+       td_complete_request(treq,-1); 
+    }
+	DPRINTF("%s -- is_start_clean is %d, copy_waterlevel is %d\n", __func__, 
+				g_atomic_int_get(&ctrl->ctrl_region->is_start_clean), g_atomic_int_get(&ctrl->ctrl_region->copy_waterlevel));
+	DPRINTF("%s -- ctrl->ctrl_region's addr is %p\n", __func__, ctrl->ctrl_region);
+}
+
+void tdhlfs_queue_write(td_driver_t *driver, td_request_t treq)
+{
+    int ret = 0;
+	struct tdhlfs_state *prv = (struct tdhlfs_state *)driver->data;
+	int      size    = treq.secs * driver->info.sector_size;
+	uint64_t offset  = treq.sec * (uint64_t)driver->info.sector_size;
+    HLFS_CTRL *ctrl = prv->hlfs_ctrl;
+    ret = hlfs_write(ctrl,treq.buf,size,offset);
+    if(ret == size){
+		DPRINTF("%s -- enter td_complete_request second parameter is 0", __func__);
+	   td_complete_request(treq, 0);
+    }else{
+		DPRINTF("%s -- enter td_complete_request second parameter is -1", __func__);
+       td_complete_request(treq,-1); 
+    }
+	DPRINTF("%s -- is_start_clean is %d, copy_waterlevel is %d\n", __func__, 
+				g_atomic_int_get(&ctrl->ctrl_region->is_start_clean), g_atomic_int_get(&ctrl->ctrl_region->copy_waterlevel));
+	DPRINTF("%s -- ctrl->ctrl_region's addr is %p\n", __func__, ctrl->ctrl_region);
+}
+
+int tdhlfs_close(td_driver_t *driver)
+{
+	struct tdhlfs_state *prv = (struct tdhlfs_state *)driver->data;
+	HLFS_CTRL *ctrl = prv->hlfs_ctrl;
+	connections--;
+	hlfs_close(ctrl);
+	deinit_hlfs(ctrl);
+	return 0;
+}
+
+int tdhlfs_get_parent_id(td_driver_t *driver, td_disk_id_t *id)
+{
+	return TD_NO_PARENT;
+}
+
+int tdhlfs_validate_parent(td_driver_t *driver,
+			  td_driver_t *pdriver, td_flag_t flags)
+{
+	return -EINVAL;
+}
+
+struct tap_disk tapdisk_hlfs = {
+	.disk_type          = "tapdisk_hlfs",
+	.flags              = 0,
+	.private_data_size  = sizeof(struct tdhlfs_state),
+	.td_open            = tdhlfs_open,
+	.td_close           = tdhlfs_close,
+	.td_queue_read      = tdhlfs_queue_read,
+	.td_queue_write     = tdhlfs_queue_write,
+	.td_get_parent_id   = tdhlfs_get_parent_id,
+	.td_validate_parent = tdhlfs_validate_parent,
+	.td_debug           = NULL,
+};
diff -Naur new-prj/blktap2/drivers/Makefile old-prj/blktap2/drivers/Makefile
--- new-prj/blktap2/drivers/Makefile	2011-11-26 13:32:06.000000000 +0800
+++ old-prj/blktap2/drivers/Makefile	2011-11-26 13:34:39.000000000 +0800
@@ -2,6 +2,15 @@
 BLKTAP_ROOT= ..
 include $(XEN_ROOT)/tools/Rules.mk
 
+HLFS_DIR = /hlfs
+HLFS_LOG = $(HLFS_DIR)/3part/log
+HADOOP_DIR = $(HLFS_DIR)/3part/hadoop
+GLIB_DIR1 = /usr/lib/glib-2.0/include
+GLIB_DIR2 = /usr/include/glib-2.0
+HADOOP_DIR1 = $(HADOOP_DIR)/include
+HADOOP_DIR2 = $(HADOOP_DIR)/lib64
+
+
 LIBVHDDIR  = $(BLKTAP_ROOT)/vhd/lib
 
 IBIN       = tapdisk2 td-util tapdisk-client tapdisk-stream tapdisk-diff
@@ -16,11 +25,16 @@
 CFLAGS    += $(CFLAGS_libxenctrl)
 CFLAGS    += -I $(LIBAIO_DIR)
 CFLAGS    += -I $(MEMSHR_DIR)
+CFLAGS    += -I $(HLFS_DIR)/src/include
+CFLAGS    += -I $(GLIB_DIR1)
+CFLAGS    += -I $(GLIB_DIR2)
+CFLAGS    += -I $(HLFS_LOG)/include
+CFLAGS    += -I $(HADOOP_DIR1)
 CFLAGS    += -D_GNU_SOURCE
 CFLAGS    += -DUSE_NFS_LOCKS
 
 ifeq ($(CONFIG_X86_64),y)
-CFLAGS            += -fPIC
+CFLAGS    += -fPIC
 endif
 
 LIBS      += -lrt -lz
@@ -33,6 +47,10 @@
 LIBS += -luuid
 endif
 
+LIBS += -L$(HLFS_DIR)/output/lib64/ -lhlfs
+LIBS += -L$(HLFS_LOG)/lib64 -llog4c
+LIBS += -L$(HADOOP_DIR2) -lhdfs
+
 REMUS-OBJS  := block-remus.o
 REMUS-OBJS  += hashtable.o
 REMUS-OBJS  += hashtable_itr.o
@@ -80,6 +98,7 @@
 
 BLK-OBJS-y  := block-aio.o
 BLK-OBJS-y  += block-ram.o
+BLK-OBJS-y  += block-hlfs.o
 BLK-OBJS-y  += block-cache.o
 BLK-OBJS-y  += block-vhd.o
 BLK-OBJS-y  += block-log.o
diff -Naur new-prj/blktap2/drivers/tapdisk2.c old-prj/blktap2/drivers/tapdisk2.c
--- new-prj/blktap2/drivers/tapdisk2.c	2011-11-26 13:32:06.000000000 +0800
+++ old-prj/blktap2/drivers/tapdisk2.c	2011-11-26 14:09:18.000000000 +0800
@@ -38,6 +38,8 @@
 #include "tapdisk-utils.h"
 #include "tapdisk-server.h"
 #include "tapdisk-control.h"
+#include "glib.h"
+#include "hlfs_log.h"
 
 static void
 usage(const char *app, int err)
@@ -54,7 +56,11 @@
 
 	control  = NULL;
 	nodaemon = 0;
-
+	setenv("LOG4C_RCPATH", "/usr/sbin/", 1);
+	if (log4c_init()) {
+		DPRINTF("77 log4c init failed!\n");
+	}
+	
 	while ((c = getopt(argc, argv, "s:Dh")) != -1) {
 		switch (c) {
 		case 'D':
diff -Naur new-prj/blktap2/drivers/tapdisk-disktype.c old-prj/blktap2/drivers/tapdisk-disktype.c
--- new-prj/blktap2/drivers/tapdisk-disktype.c	2011-11-26 13:32:06.000000000 +0800
+++ old-prj/blktap2/drivers/tapdisk-disktype.c	2011-11-26 14:11:36.000000000 +0800
@@ -32,6 +32,7 @@
 
 #include "tapdisk-disktype.h"
 #include "tapdisk-message.h"
+#include "tapdisk.h"
 
 static const disk_info_t aio_disk = {
        "aio",
@@ -82,11 +83,11 @@
        1,
 };
 
-static const disk_info_t vhd_index_disk = {
+/*static const disk_info_t vhd_index_disk = {
        "vhdi",
        "vhd index image (vhdi)",
        1,
-};
+}; */
 
 static const disk_info_t log_disk = {
 	"log",
@@ -100,6 +101,12 @@
        0,
 };
 
+static const disk_info_t hlfs_disk = {
+       "hlfs",
+       "hlfs disk replicator (hlfs)",
+       0,
+};
+
 const disk_info_t *tapdisk_disk_types[] = {
 	[DISK_TYPE_AIO]	= &aio_disk,
 	[DISK_TYPE_SYNC]	= &sync_disk,
@@ -110,8 +117,9 @@
 	[DISK_TYPE_QCOW]	= &qcow_disk,
 	[DISK_TYPE_BLOCK_CACHE] = &block_cache_disk,
 	[DISK_TYPE_LOG]	= &log_disk,
-	[DISK_TYPE_VINDEX]	= &vhd_index_disk,
+	//[DISK_TYPE_VINDEX]	= &vhd_index_disk,
 	[DISK_TYPE_REMUS]	= &remus_disk,
+	[DISK_TYPE_HLFS]	= &hlfs_disk,
 	0,
 };
 
@@ -123,9 +131,10 @@
 extern struct tap_disk tapdisk_ram;
 extern struct tap_disk tapdisk_qcow;
 extern struct tap_disk tapdisk_block_cache;
-extern struct tap_disk tapdisk_vhd_index;
+//extern struct tap_disk tapdisk_vhd_index;
 extern struct tap_disk tapdisk_log;
 extern struct tap_disk tapdisk_remus;
+extern struct tap_disk tapdisk_hlfs;
 
 const struct tap_disk *tapdisk_disk_drivers[] = {
 	[DISK_TYPE_AIO]         = &tapdisk_aio,
@@ -137,9 +146,10 @@
 	[DISK_TYPE_RAM]         = &tapdisk_ram,
 	[DISK_TYPE_QCOW]        = &tapdisk_qcow,
 	[DISK_TYPE_BLOCK_CACHE] = &tapdisk_block_cache,
-	[DISK_TYPE_VINDEX]      = &tapdisk_vhd_index,
+	//[DISK_TYPE_VINDEX]      = &tapdisk_vhd_index,
 	[DISK_TYPE_LOG]         = &tapdisk_log,
 	[DISK_TYPE_REMUS]       = &tapdisk_remus,
+	[DISK_TYPE_HLFS]       = &tapdisk_hlfs,
 	0,
 };
 
@@ -147,15 +157,24 @@
 tapdisk_disktype_find(const char *name)
 {
 	const disk_info_t *info;
+	const disk_info_t *_info;
 	int i;
 
 	for (i = 0; info = tapdisk_disk_types[i], info != NULL; ++i) {
-		if (strcmp(name, info->name))
+		DPRINTF("77 i is %d info->name is %s\n", i,info->name);
+		_info = tapdisk_disk_types[11];
+		DPRINTF("77 tapdisk_disk_types[11] is %s\n", _info->name);
+		if (strcmp(name, info->name)) {
+			if (i == 9) {
+				i += 1;
+			}
 			continue;
+		}
 
+		DPRINTF("77 1 i is %d\n", i);
 		if (!tapdisk_disk_drivers[i])
 			return -ENOSYS;
-
+		DPRINTF("77 2 i is %d\n", i);
 		return i;
 	}
 
@@ -168,21 +187,19 @@
 	char name[DISK_TYPE_NAME_MAX], *ptr;
 	size_t len;
 	int type;
-
+	
 	ptr = strchr(params, ':');
 	if (!ptr)
 		return -EINVAL;
 
 	len = ptr - params;
-
 	if (len > sizeof(name) - 1)
 		return -ENAMETOOLONG;
 
 	memset(name, 0, sizeof(name));
 	strncpy(name, params, len);
-
+	
 	type = tapdisk_disktype_find(name);
-
 	if (type >= 0)
 		*_path = params + len + 1;
 
diff -Naur new-prj/blktap2/drivers/tapdisk-disktype.h old-prj/blktap2/drivers/tapdisk-disktype.h
--- new-prj/blktap2/drivers/tapdisk-disktype.h	2011-11-26 13:32:06.000000000 +0800
+++ old-prj/blktap2/drivers/tapdisk-disktype.h	2011-11-26 13:34:39.000000000 +0800
@@ -39,7 +39,8 @@
 #define DISK_TYPE_BLOCK_CACHE 7
 #define DISK_TYPE_LOG         8
 #define DISK_TYPE_REMUS       9
-#define DISK_TYPE_VINDEX      10
+//#define DISK_TYPE_VINDEX      10
+#define DISK_TYPE_HLFS	      11
 
 #define DISK_TYPE_NAME_MAX    32
 
diff -Naur new-prj/python/xen/xend/server/BlktapController.py old-prj/python/xen/xend/server/BlktapController.py
--- new-prj/python/xen/xend/server/BlktapController.py	2011-11-26 13:32:05.000000000 +0800
+++ old-prj/python/xen/xend/server/BlktapController.py	2011-11-26 13:33:32.000000000 +0800
@@ -24,6 +24,7 @@
     'qcow',
     'vhd',
     'remus',
+	'hlfs',
     ]
 
 blktap_disk_types = blktap1_disk_types + blktap2_disk_types
