diff -Nhur qemu.org/block/hlfs.c qemu/block/hlfs.c
--- qemu.org/block/hlfs.c	1969-12-31 16:00:00.000000000 -0800
+++ qemu/block/hlfs.c	2012-06-01 06:00:35.560873494 -0700
@@ -0,0 +1,507 @@
+/*
+  *  Copyright (C) 2012      KangHua <kanghua151@gmail.com> 
+  *
+  *  This program is free software; you can redistribute it and/or modify it
+  *  under the terms of the GNU General Public License version 2 as published by
+  *  the Free Software Foundation.
+ */
+
+#include "qemu-common.h"
+#include "qemu-error.h"
+#include "qemu_socket.h"
+#include "block_int.h"
+#include "bitops.h"
+#include "api/hlfs.h"
+#include "storage_helper.h"
+#include "comm_define.h"
+#define DEBUG_HLBS
+#undef dprintf
+#ifdef DEBUG_HLBS
+#define dprintf(fmt, args...)                                       \
+    do {                                                            \
+        fprintf(stdout, "%s %d: " fmt, __func__, __LINE__, ##args); \
+    } while (0)
+#else
+#define dprintf(fmt, args...)
+#endif
+
+#define HLBS_MAX_VDI_SIZE 8192UL*8192UL*8192UL*8192UL
+#define SECTOR_SIZE 512
+typedef struct BDRVHLBSState {
+  struct hlfs_ctrl * hctrl;
+  char *snapshot;
+  char *uri;
+  //CoMutex lock;
+} BDRVHLBSState;
+
+
+/*
+ * Parse a filename
+ *
+ * filename must be one of the following formats:
+ *   1. [vdiname]
+ *   2. [vdiname]%[snapshot]
+ *   * vdiname format --
+ *   * local:///tmp/testenv/testfs
+ *   * hdfs:///tmp/testenv/testfs
+ *   * hdfs://localhost:8020/tmp/testenv/testfs
+ *   * hdfs://localhost/tmp/testenv/testfs
+ *   * hdfs://192.168.0.1:8020/tmp/testenv/testfs
+ *
+ */
+static int parse_vdiname(BDRVHLBSState *s, const char *filename,
+                         char *vdi, char *snapshot)
+{
+    if(NULL == filename){
+        return -1;
+    }
+    gchar **v = g_strsplit(filename,"%",2);
+    if(g_strv_length(v)==1){
+        strcpy(vdi,v[0]);
+        s->uri = g_strdup(vdi);
+    }else if(g_strv_length(v)==2){
+        strcpy(vdi,v[0]);
+        strcpy(snapshot,v[1]);
+        s->uri = g_strdup(vdi);
+        s->snapshot = g_strdup(snapshot);
+    }else{
+        goto out;
+    }
+
+    return 0;
+out:
+    g_strfreev(v);
+    return -1; 
+}
+
+static int hlbs_open(BlockDriverState *bs, const char *filename, int flags)
+{
+    printf("enter func %s\n", __func__);
+    int ret;
+    BDRVHLBSState *s = bs->opaque;
+    char vdi[265];
+    char snapshot[HLFS_FILE_NAME_MAX];
+    strstart(filename, "hlfs:", (const char **)&filename);
+    memset(snapshot, 0, sizeof(snapshot));
+    memset(vdi, 0, sizeof(vdi));
+    if (parse_vdiname(s,filename,vdi,snapshot) < 0) {
+        goto out;
+    }
+
+    HLFS_CTRL * ctrl = init_hlfs(vdi);
+    if (0 != strlen(snapshot)) {
+        //dprintf("%" PRIx32 " snapshot inode was open.\n", snapshot);
+        dprintf("snapshot:%s was open.\n", snapshot);
+        ret = hlfs_open_by_snapshot(ctrl,snapshot,1);
+    }else{
+        ret = hlfs_open(ctrl,1);
+    }
+    g_assert(ret == 0);
+    s->hctrl=ctrl;
+    bs->total_sectors = ctrl->sb.max_fs_size*1024*1024 / SECTOR_SIZE;
+    //qemu_co_mutex_init(&s->lock);
+    return 0;
+out:
+    if (s->hctrl!=NULL) {
+        hlfs_close(s->hctrl);
+        deinit_hlfs(s->hctrl);
+    }
+    return -1;
+}
+
+static int hlbs_create(const char *filename, QEMUOptionParameter *options)
+{
+	printf("enter func %s\n", __func__);
+	int ret;
+	int64_t vdi_size = 0;
+	char *backing_file = NULL;
+	BDRVHLBSState s;
+	int prealloc = 0;
+	char vdi[256]; 
+	char snapshot[256];
+	const char *vdiname;
+	strstart(filename, "hlfs:", &vdiname);
+	memset(&s, 0,sizeof(s));
+	memset(vdi, 0, sizeof(vdi));
+	memset(snapshot, 0, sizeof(snapshot));
+	if (parse_vdiname(&s,vdiname, vdi, snapshot) < 0) {
+		error_report("invalid filename");
+		return -EINVAL;
+	}
+
+	while (options && options->name) {
+		if (!strcmp(options->name, BLOCK_OPT_SIZE)) {
+			vdi_size = options->value.n;
+		} else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {
+
+			backing_file = options->value.s;
+			printf("----back_file:%s\n",backing_file);
+		} else if (!strcmp(options->name, BLOCK_OPT_PREALLOC)) {
+			if (!options->value.s || !strcmp(options->value.s, "off")) {
+				prealloc = 0;
+			} else if (!strcmp(options->value.s, "full")) {
+				prealloc = 1;
+			} else {
+				error_report("Invalid preallocation mode: '%s'",
+						options->value.s);
+				return -EINVAL;
+			}
+		}
+		options++;
+	}
+
+	if (vdi_size > HLBS_MAX_VDI_SIZE) {
+		error_report("too big image size");
+		return -EINVAL;
+	}
+
+	if (backing_file) {
+		char *father_uri_with_snapshot;
+	        strstart(backing_file, "hlfs:", &father_uri_with_snapshot);
+		char *son_uri = vdi;
+                //g_message("father uri+snpashot:%s,son_uri:%s",father_uri_with_snapshot,son_uri);
+	        char *father_uri=NULL;
+		char *father_snapshot = NULL;
+		gchar **v=NULL;
+		v = g_strsplit(father_uri_with_snapshot,"%",2);
+		if(g_strv_length(v)!=2){
+			g_strfreev(v);
+			g_message("not give snapshot for base:%s",father_uri_with_snapshot);
+			return -1; 
+		}
+		father_uri = g_strdup(v[0]);
+		father_snapshot = g_strdup(v[1]);
+		g_strfreev(v);
+		if(0 == strcmp(father_uri,son_uri)){
+			g_message("father uri can not equal son uri");
+			return -1;
+		}
+		struct back_storage *father_storage = init_storage_handler(father_uri);
+		if(NULL ==father_storage){
+			g_message("can not get storage handler for father_uri:%s",father_uri);
+			return -1;
+		}
+		struct back_storage *son_storage = init_storage_handler(son_uri);
+		if(NULL ==son_storage){
+			g_message("can not get storage handler for son_uri:%s",son_uri);
+			return -1;
+		}
+		/*  check son is exist and empty must  */
+		if((0!=son_storage->bs_file_is_exist(son_storage,NULL)) || (0!=son_storage->bs_file_is_exist(son_storage,"superblock"))){
+			g_message("hlfs with uri:%s has not exist,please mkfs it first!",son_uri);
+			return -1;
+		}
+
+		uint32_t segno=0;
+		uint32_t offset=0;
+		if(0!=get_cur_latest_segment_info(son_storage,&segno,&offset)){
+			g_message("can not get latest seg info for son ");
+		}else{
+			if(segno != 0 || offset != 0){
+				g_message("son hlfs must empty");
+				return -1; 
+			}
+		}
+		/* check son is not clone already */
+		char *content =NULL;
+		uint32_t size = 0;
+		if(0 != file_get_contents(son_storage,"superblock",&content,&size)){
+			g_message("can not read superblock");
+		}
+		GKeyFile * sb_keyfile = g_key_file_new();
+		if(FALSE == g_key_file_load_from_data(sb_keyfile,content,size,G_KEY_FILE_NONE,NULL)){
+			g_message("superblock file format is not key value pairs");
+			return -1;
+		}
+		gchar   * _father_uri =  g_key_file_get_string(sb_keyfile,"METADATA","father_uri",NULL);
+
+		printf("father uri: %s\n",_father_uri);
+		if(_father_uri != NULL){
+			g_message("uri:%s has clone :%s",son_uri,_father_uri);
+			return -1;
+		}
+		g_free(content);
+		/*  read father's snapshot 's inode */
+		uint64_t inode_addr;
+		struct snapshot *ss = NULL;
+		if (0 > load_snapshot_by_name(father_storage, SNAPSHOT_FILE, &ss, father_snapshot)) {
+			g_message("load uri:%s ss by name:%s error",father_uri,father_snapshot);
+			g_free(ss);
+			return -1;
+		}
+		inode_addr = ss->inode_addr;
+		g_free(ss);
+		uint32_t    father_seg_size = 0;
+		uint32_t    father_block_size = 0;
+		uint64_t    father_max_fs_size = 0;
+		if (0 != read_fs_meta(father_storage,&father_seg_size,&father_block_size,&father_max_fs_size)){
+			g_message("can not read father uri meta");	
+			return -1;	
+		}
+		segno = get_segno(inode_addr);
+		uint32_t son_block_size =  g_key_file_get_integer(sb_keyfile,"METADATA","block_size",NULL);
+		uint32_t son_seg_size =  g_key_file_get_integer(sb_keyfile,"METADATA","segment_size",NULL); 	
+		if (son_block_size != father_block_size || father_seg_size!=son_seg_size){
+			g_message("sorry , now father segsize and block sizee must same as son!!!");	
+			return -1;	
+		}		
+		g_key_file_set_uint64(sb_keyfile,"METADATA","from_segno",segno+1);
+		g_key_file_set_string(sb_keyfile,"METADATA","father_uri",father_uri);
+		g_key_file_set_string(sb_keyfile,"METADATA","father_ss",father_snapshot);	
+		g_key_file_set_uint64(sb_keyfile,"METADATA","snapshot_inode",inode_addr);
+		g_key_file_set_uint64(sb_keyfile,"METADATA","max_fs_size",father_max_fs_size);	
+		gchar *data = g_key_file_to_data(sb_keyfile,NULL,NULL);
+		//g_message("key file data :%s",data);
+		if(0 != son_storage->bs_file_delete(son_storage,"superblock")){
+			g_message("can not delete old superblock file");
+			return -1; 
+		}
+		if(0 != file_append_contents(son_storage,"superblock",(char*)data,strlen(data)+1)){
+			g_message("can not write superblock file");
+			return -1;
+		}
+		deinit_storage_handler(son_storage);
+		deinit_storage_handler(father_storage);
+
+	}else{
+		struct back_storage *storage = init_storage_handler(vdi);
+		if(NULL ==storage){
+			g_message("can not get storage handler for uri:%s",vdi);
+			return -1;
+		}
+		if((0==storage->bs_file_is_exist(storage,NULL)) && (0==storage->bs_file_is_exist(storage,"superblock"))){
+			g_message("hlfs with uri:%s has exist",vdi);
+			return 1;
+		}
+		if( 0!=storage->bs_file_mkdir(storage,NULL)){
+			g_message("can not mkdir for our fs %s",vdi);
+			return -1;
+		}
+		GKeyFile *sb_keyfile= g_key_file_new();
+		g_key_file_set_string(sb_keyfile,"METADATA","uri",vdi);
+		g_key_file_set_integer(sb_keyfile,"METADATA","block_size",8192);
+		g_key_file_set_integer(sb_keyfile,"METADATA","segment_size",67108864);
+		g_key_file_set_integer(sb_keyfile,"METADATA","max_fs_size",vdi_size/(1024*1024));
+		gchar *data = g_key_file_to_data(sb_keyfile,NULL,NULL);
+		//g_message("key file data :%s",data);
+		char *head,*hostname,*dir,*fs_name;
+		int port;
+		parse_from_uri(vdi,&head,&hostname,&dir,&fs_name,&port);
+		char *sb_file_path = g_build_filename(dir,fs_name,"superblock",NULL);
+		//g_message("sb file path %s",sb_file_path);
+		bs_file_t file = storage->bs_file_create(storage,"superblock");
+		//g_message("sb file path 1%s",sb_file_path);
+		if (NULL == file) {
+			g_message("open file :superblock failed");
+			g_free(sb_file_path);
+			return -1;
+		}
+		//g_message("sb file path 2%s",sb_file_path);
+		int size = storage->bs_file_append(storage, file,(char*)data,strlen(data)+1);
+		if(size != strlen(data)+1){
+			g_message("can not write superblock file");
+			g_free(sb_file_path);
+		}
+		storage->bs_file_flush(storage,file);
+		storage->bs_file_close(storage,file);
+		deinit_storage_handler(storage);
+	}
+	return 0;
+}
+
+static void hlbs_close(BlockDriverState *bs)
+{
+    printf("enter func %s\n", __func__);
+    BDRVHLBSState *s = bs->opaque;
+    if (s->hctrl!=NULL) {
+        hlfs_close(s->hctrl);
+        deinit_hlfs(s->hctrl);
+    }
+}
+
+static int64_t hlbs_getlength(BlockDriverState *bs)
+{
+
+    printf("enter func %s\n", __func__);
+    BDRVHLBSState *s = bs->opaque;
+    return s->hctrl->sb.max_fs_size*1024*1024;
+}
+static int64_t hlbs_get_allocated_file_size(BlockDriverState *bs)
+{
+    printf("enter func %s\n", __func__);
+    BDRVHLBSState *s = bs->opaque;
+    return s->hctrl->inode.length;
+}
+
+
+static int hlbs_write(BlockDriverState *bs, int64_t sector_num,
+                        const uint8_t *buf,int nb_sectors)
+{   
+    printf("enter func %s\n", __func__);
+    int ret;
+    BDRVHLBSState *s = bs->opaque;
+    uint32_t write_size = nb_sectors*512;
+    uint64_t offset = sector_num*512;
+    ret = hlfs_write(s->hctrl,(char*)buf,write_size,offset);
+    return ret;
+
+}
+
+static int hlbs_read(BlockDriverState *bs, int64_t sector_num,
+                       uint8_t *buf,int nb_sectors)
+{
+
+    printf("enter func %s\n", __func__);
+    int ret;
+    BDRVHLBSState *s = bs->opaque;
+    uint32_t read_size = nb_sectors*512;
+    uint64_t offset = sector_num*512;
+    ret = hlfs_read(s->hctrl,(char*)buf,read_size,offset);
+    return ret;
+}
+
+static int hlbs_flush(BlockDriverState *bs)
+{
+
+    printf("enter func %s\n", __func__);
+    int ret;
+    BDRVHLBSState *s = bs->opaque;
+    ret = hlfs_flush(s->hctrl);
+    return ret;
+}
+
+static int hlbs_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)
+{
+
+    printf("enter func %s\n", __func__);
+    BDRVHLBSState *s = bs->opaque;
+    int ret;
+    dprintf("sn_info: name %s id_str %s vm_state_size %d\n", sn_info->name, sn_info->id_str,
+            sn_info->vm_state_size);
+    dprintf("%s %s\n", sn_info->name, sn_info->id_str);
+    ret = hlfs_take_snapshot(s->hctrl,sn_info->name);
+    return 0;
+}
+
+static int hlbs_snapshot_goto(BlockDriverState *bs, const char *snapshot)
+{
+
+    printf("enter func %s\n", __func__);
+    int ret;
+    BDRVHLBSState *s = bs->opaque;
+    char vdi[265];
+    memset(vdi, 0, sizeof(vdi));
+    strncpy(vdi, s->hctrl->storage->uri, sizeof(vdi));
+    hlfs_close(s->hctrl);
+    deinit_hlfs(s->hctrl);
+    HLFS_CTRL *ctrl = init_hlfs(vdi);
+    s->hctrl = ctrl;
+    ret = hlfs_open_by_snapshot(ctrl,snapshot,1);
+    if(ret!=0){
+       //g_assert(ret == 0);
+       goto out;
+    }
+    s->hctrl=ctrl;
+    s->uri = g_strdup(vdi);
+    s->snapshot = g_strdup(vdi);
+    bs->total_sectors = ctrl->sb.max_fs_size*1024*1024 / SECTOR_SIZE;
+    //qemu_co_mutex_init(&s->lock);
+    return 0;
+out:
+    if (s->hctrl!=NULL) {
+        hlfs_close(s->hctrl);
+        deinit_hlfs(s->hctrl);
+    }
+    return -1;
+}
+
+static int hlbs_snapshot_delete(BlockDriverState *bs, const char *snapshot)
+{
+
+    printf("enter func %s\n", __func__);
+    /* FIXME: Delete specified snapshot id.  */
+    BDRVHLBSState *s = bs->opaque;
+    int ret;
+    ret = hlfs_rm_snapshot(s->hctrl->storage->uri,snapshot);
+    return 0;
+}
+
+static int hlbs_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)
+{
+
+    printf("enter func %s\n", __func__);
+    BDRVHLBSState *s = bs->opaque;
+    int ret;
+    int num_entries;
+    struct snapshot * snapshots =  hlfs_get_all_snapshots(s->hctrl->storage->uri,&num_entries);
+    printf("snapshot count:%d\n",num_entries);
+    QEMUSnapshotInfo *sn_tab = NULL;
+    struct snapshot * snapshot =snapshots;
+    sn_tab = g_malloc0(num_entries * sizeof(*sn_tab));
+    int i;
+    for(i=0;i<num_entries;i++){
+            printf("---snapshot:%s----",snapshot->sname);
+            sn_tab[i].date_sec  = snapshot->timestamp * 1000;
+            sn_tab[i].date_nsec = 0;
+            sn_tab[i].vm_state_size = 0;
+            sn_tab[i].vm_clock_nsec = 0;
+            snprintf(sn_tab[i].id_str, sizeof(sn_tab[i].id_str), "%u",0);
+            strncpy(sn_tab[i].name,snapshot->sname,MIN(sizeof(sn_tab[i].name), strlen(snapshot->sname)));
+            snapshot++;
+    }
+    *psn_tab = sn_tab;
+    if(snapshots!=NULL){
+        g_free(snapshots);
+    }
+    return num_entries;
+}
+
+
+static QEMUOptionParameter hlbs_create_options[] = {
+    {
+        .name = BLOCK_OPT_SIZE,
+        .type = OPT_SIZE,
+        .help = "Virtual disk size"
+    },
+    {
+        .name = BLOCK_OPT_BACKING_FILE,
+        .type = OPT_STRING,
+        .help = "File name of a base image"
+    },
+    {
+        .name = BLOCK_OPT_PREALLOC,
+        .type = OPT_STRING,
+        .help = "Preallocation mode (allowed values: off, full)"
+    },
+    { NULL }
+};
+
+static BlockDriver bdrv_hlbs = {
+    .format_name    = "hlfs",
+    .protocol_name  = "hlfs",
+    .instance_size  = sizeof(BDRVHLBSState),
+    .bdrv_file_open = hlbs_open,
+    .bdrv_close     = hlbs_close,
+    .bdrv_create    = hlbs_create,
+    .bdrv_getlength = hlbs_getlength,
+
+    .bdrv_read  = hlbs_read,
+    .bdrv_write = hlbs_write,
+    .bdrv_get_allocated_file_size  = hlbs_get_allocated_file_size,
+
+    .bdrv_snapshot_create   = hlbs_snapshot_create,
+    .bdrv_snapshot_goto     = hlbs_snapshot_goto,
+    .bdrv_snapshot_delete   = hlbs_snapshot_delete,
+    .bdrv_snapshot_list     = hlbs_snapshot_list,
+
+    .create_options = hlbs_create_options,
+};
+
+static void bdrv_hlbs_init(void)
+{
+    if (log4c_init()) {
+        g_message("log4c_init error!");
+    }
+    bdrv_register(&bdrv_hlbs);
+}
+block_init(bdrv_hlbs_init);
Binary files qemu.org/block/.hlfs.c.swp and qemu/block/.hlfs.c.swp differ
diff -Nhur qemu.org/configure qemu/configure
--- qemu.org/configure	2012-05-29 04:59:47.090535414 -0700
+++ qemu/configure	2012-06-01 05:39:01.580892056 -0700
@@ -194,6 +194,7 @@
 guest_agent="yes"
 libiscsi=""
 coroutine=""
+hlfs=""
 
 # parse CC options first
 for opt do
@@ -824,6 +825,11 @@
   ;;
   --disable-guest-agent) guest_agent="no"
   ;;
+  --enable-hlfs) hlfs="yes"
+  ;;
+  --disable-hlfs) hlfs="no"
+  ;;
+
   *) echo "ERROR: unknown option $opt"; show_help="yes"
   ;;
   esac
@@ -1108,6 +1114,7 @@
 echo "  --enable-usb-redir       enable usb network redirection support"
 echo "  --disable-guest-agent    disable building of the QEMU Guest Agent"
 echo "  --enable-guest-agent     enable building of the QEMU Guest Agent"
+echo "  --enable-hlfs            enable building the log structrue filesystem based on hdfs (hlfs)"
 echo "  --with-coroutine=BACKEND coroutine backend. Supported options:"
 echo "                           gthread, ucontext, sigaltstack, windows"
 echo ""
@@ -2125,6 +2132,55 @@
 fi
 
 ##########################################
+# hlfs probe
+if test "$hlfs" != "no" ; then
+  cat > $TMPC <<EOF
+#include <stdio.h>
+#include <api/hlfs.h>
+int main(void) {
+    return 0;
+}
+EOF
+GLIB_DIR1_INC=/usr/lib/glib-2.0/include
+GLIB_DIR2_INC=/usr/include/glib-2.0
+HLFS_DIR=/home/kanghua/workshop3.bak/hlfs
+LOG4C_DIR=$HLFS_DIR/3part/log
+HDFS_DIR=$HLFS_DIR/3part/hadoop
+JVM_DIR=/usr/lib/jvm/java-6-sun/
+
+if [ `getconf LONG_BIT` -eq "64" ];then
+CLIBS="-L$LOG4C_DIR/lib64"
+CLIBS="-L$HDFS_DIR/lib64 $CLIBS"
+CLIBS="-L$HLFS_DIR/output/lib64  $CLIBS"
+CLIBS="-L$JVM_DIR/jre/lib/amd64/server/ $CLIBS"
+fi
+
+if [ `getconf LONG_BIT` -eq "32" ];then
+CLIBS="-L$LOG4C_DIR/lib32"
+CLIBS="-L$HDFS_DIR/lib32 $CLIBS"
+CLIBS="-L$JVM_DIR/jre/lib/i386/server $CLIBS"
+CLIBS="-L$HLFS_DIR/output/lib32  $CLIBS"
+fi
+
+CFLAGS="-I$GLIB_DIR1_INC"
+CFLAGS="-I$GLIB_DIR2_INC $CFLAGS"
+CFLAGS="-I$HLFS_DIR/src/include $CFLAGS"
+CFLAGS="-I$LOG4C_DIR/include $CFLAGS"
+
+hlfs_libs="$CLIBS -lhlfs -llog4c -lglib-2.0 -lgthread-2.0 -lrt -lhdfs -ljvm"
+if compile_prog "$CFLAGS" "$CLIBS $hlfs_libs" ; then
+    hlfs=yes
+    libs_tools="$hlfs_libs $libs_tools"
+    libs_softmmu="$hlfs_libs $libs_softmmu"
+else
+    if test "$hlfs" = "yes" ; then
+      feature_not_found "hlfs block device"
+    fi
+    hlfs=no
+  fi
+fi
+
+##########################################
 # linux-aio probe
 
 if test "$linux_aio" != "no" ; then
@@ -3007,6 +3063,7 @@
 echo "Trace output file $trace_file-<pid>"
 echo "spice support     $spice"
 echo "rbd support       $rbd"
+echo "hlfs support      $hlfs"
 echo "xfsctl support    $xfs"
 echo "nss used          $smartcard_nss"
 echo "usb net redir     $usb_redir"
@@ -3853,6 +3910,11 @@
   echo "CONFIG_TCI_DIS=y"  >> $libdis_config_mak
 fi
 
+if test "$hlfs" = "yes" ; then
+  echo "CONFIG_HLFS=y"  >> $config_target_mak
+fi
+
+
 case "$ARCH" in
 alpha)
   # Ensure there's only a single GP
diff -Nhur qemu.org/log4crc qemu/log4crc
--- qemu.org/log4crc	1969-12-31 16:00:00.000000000 -0800
+++ qemu/log4crc	2012-06-01 05:39:55.840891584 -0700
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE log4c SYSTEM "">
+
+<log4c version="1.2.1">
+	<!-- fatal error warn notice info debug trace -->
+	<config>
+		<bufsize>0</bufsize>
+		<debug level="0"/>
+		<nocleanup>0</nocleanup>
+		<reread>1</reread>
+	</config>
+
+	<category name="hlfslog" priority="debug" appender="myrollingfileappender" />
+	<rollingpolicy name="myrollingpolicy" type="sizewin" maxsize="1048576000" maxnum="10" />
+	<appender name="myrollingfileappender" type="rollingfile" logdir="./" prefix="log" layout="dated" rollingpolicy="myrollingpolicy" />
+	<layout name="dated" type="dated"/>
+</log4c>
diff -Nhur qemu.org/Makefile.objs qemu/Makefile.objs
--- qemu.org/Makefile.objs	2012-05-29 04:59:47.060535409 -0700
+++ qemu/Makefile.objs	2012-06-01 05:39:10.970892284 -0700
@@ -52,13 +52,14 @@
 block-nested-y += qcow2.o qcow2-refcount.o qcow2-cluster.o qcow2-snapshot.o qcow2-cache.o
 block-nested-y += qed.o qed-gencb.o qed-l2-cache.o qed-table.o qed-cluster.o
 block-nested-y += qed-check.o
-block-nested-y += parallels.o nbd.o blkdebug.o sheepdog.o blkverify.o
+block-nested-y += parallels.o nbd.o blkdebug.o sheepdog.o blkverify.o hlfs.o
 block-nested-y += stream.o
 block-nested-$(CONFIG_WIN32) += raw-win32.o
 block-nested-$(CONFIG_POSIX) += raw-posix.o
 block-nested-$(CONFIG_LIBISCSI) += iscsi.o
 block-nested-$(CONFIG_CURL) += curl.o
 block-nested-$(CONFIG_RBD) += rbd.o
+block-nested-$(CONFIG_HLFS) += hlfs.o
 
 block-obj-y +=  $(addprefix block/, $(block-nested-y))
 
