#summary 性能优化.

= 调优介绍 =

先大刀阔斧完完成从无到有的功能，初步跑通，增强自信。那下一步就该是抽丝剥茧搬的调优过程了。

关于调优的几个断言——
 * 调优过程将是无止尽的.
 * 任何优化都是有代价的.

HLFS项目存在大量可调整的理由和办法，可谓仁者见仁智者见智。我们将从从收益角度和实现代价考虑，逐步开展。
因为很多优化办法具备普遍意义，所以我们费一些笔墨描述之。
 

= 调优点 =

== indirect block read cache ==
我们知道，每次访问data block，只要需要从磁盘中载入或者写入，就必须首先访问indirect block（如果db在cache则不需要再从磁盘载入），显然这些indirect block访问相当频繁，如果访问ib时，每每都操作磁盘，那对性能无疑是个重大损失。所以我们尽可能希望最近访问的ib能被缓存起来，从而避免磁盘访问。
所以，我们实现ICACHE缓存（indirect block cache），和DCATCH(data block cache)写缓存相比，ICACHE最大特点是它属于读缓存，并不需要向DCACHE那样WRITEBACK ——　因为ib会随db一起在dump_log时被写到后台。 ICACHE实现和DACHE有所相似，不过没有后台刷新线程。
另外值得一提的是，iblock当前编号规则按照简单的遍历顺序而给定，且和dblock相互独立。这是当前简单实现，后期可以采用基树替代简单hash；采用iblock dblock统一编号带台当前独立编号。

== segment file handler reuse ==
我们知道，每次读写一个段文件都要经历打开文件-访问文件-关闭文件几个过程，这种频繁的打开和关闭无疑是性能提升的重要障碍，所以我们要想方设法降低打开文件和关闭文件操作。
比较理想办法应该是：
 * 预先打开段文件（比如每次需要打开或创建段文件时，一次行打开或创建后续n个),从而避免频繁打开段文件；
 * 延迟关闭段文件，或者惰性关闭其（比如，每次访问段内容后并非立刻关闭段文件句柄，而是延后关闭）

我们本次优化，先简单处理——实施延迟关闭方式减少每次block访问都打开关闭文件。

== 锁优化 == 
目前系统最大锁争用在于：read_block 和 append_log之间的锁竞争。可能引起并发的几个线是：
 # cache 回写动作
 # seg clean 读写动作
 # 读写操作引起的read block读动作

我们要争取所有的IO动作不再锁内，也就是竞争区中不包含耗时的IO动作。
所以制定以下几个策略：
 # 修改内存索引iblock和磁盘数据的次序调整为——先修改磁盘数据再修改内存索引，而上锁区间从原来的整个append_log，降低到只包含内存索引修改，甚至可以不加锁（这里不必担心读到老数据，因为我们的cache会确保读到最新）
 # seg clean task 中的搬迁动作采用乐观锁方式—— 因为seg clean操作其实是“check and modify"动作，该动作要求原子完成（否则就有可能造成数据错乱），所以上锁在所难免，但这个锁区域显然不小。不过我们seg clean任务执行特征是延后且不紧急动作，只有当没有真实写入动作时才会抽空执行，因此我们不妨简化锁设计，采用乐观锁方式，即：
  # seg clean task 在 check 动作前纪录inode修改时间戳
  # seg clean task 在 modify 内存inode结构前发现inode时间戳已被修改则放弃本次modify动作，如果时间戳没有被修改才执行modify动作。

== 优化内存使用 ==
 # 对于频繁调用路径上内存使用应尽量避免动态堆上分配。
 

--待续



